#ifndef __SUBSCRIPTION_H__
#define __SUBSCRIPTION_H__
#include "csv.h"
#include "date.h"
#include "error.h"
#include "person.h"
#include "watchstack.h"
#include <string.h>

#define MAX_DOCUMENT 9
#define MAX_PLAN 250

#define NUM_FIELDS_SUBSCRIPTION 7

typedef struct _tSubscription {
    int id;
    char document[MAX_DOCUMENT + 1];
    tDate start_date;
    tDate end_date;
    char plan[MAX_PLAN + 1];
    float price;
    int numDevices;
    tFilmstack watchlist;
} tSubscription;

typedef struct _tSubscriptions {
    tSubscription *elems;
    int count;
} tSubscriptions;

//////////////////////////////////
// Available methods
//////////////////////////////////

// Parse input from CSVEntry
void subscription_parse(tSubscription* data, tCSVEntry entry);

// Copy the data from the source to destination (individual data)
void subscription_cpy(tSubscription* destination, tSubscription source);

// Get subscription data using a string
void subscription_get(tSubscription data, char* buffer);

// Compare two subscription
bool subscription_equal(tSubscription subscription1, tSubscription subscription2);

// Initialize subscriptions data
tApiError subscriptions_init(tSubscriptions* data);

// Return the number of subscriptions
int subscriptions_len(tSubscriptions data);

// Add a new subscription
tApiError subscriptions_add(tSubscriptions* data, tPeople people, tSubscription subscription);

// Remove a subscription
tApiError subscriptions_del(tSubscriptions* data, int id);

// Get subscription data of position index using a string
void subscriptions_get(tSubscriptions data, int index, char* buffer);

// Returns the position of a subscription looking for id's subscription. -1 if it does not exist
int subscriptions_find(tSubscriptions data, int id);

// Print subscriptions data
void subscriptions_print(tSubscriptions data);

// Remove all elements
tApiError subscriptions_free(tSubscriptions* data);

// Calculate vipLevel for a person based on their subscriptions
int calculate_vipLevel(tSubscriptions* data, const char* document);

// Update the vipLevel of each person 
tApiError update_vipLevel(tSubscriptions *data, tPeople* people);

// Return a pointer to the longest film of the list
char* popularFilm_find(tSubscriptions data);
    
    // Initialize variables to track the most popular film
    char* mostPopularFilm = NULL;
    int maxOccurrences = 0;
    
    // For each subscription, check all films in its watchlist
    for (int i = 0; i < data.count; i++) {
        tFilmstackNode* currentNode = data.elems[i].watchlist.top;
        
        // Process each film in the current subscription's watchlist
        while (currentNode != NULL) {
            // Count occurrences of this film across all watchlists
            int occurrences = 0;
            
            // Check all subscriptions for this film
            for (int j = 0; j < data.count; j++) {
                tFilmstackNode* checkNode = data.elems[j].watchlist.top;
                
                // Search through this subscription's watchlist
                while (checkNode != NULL) {
                    // Compare film names
                    if (strcmp(currentNode->elem.name, checkNode->elem.name) == 0) {
                        occurrences++;
                    }
                    checkNode = checkNode->next;
                }
            }
            
            // Update most popular film if this one has more occurrences
            if (occurrences > maxOccurrences) {
                maxOccurrences = occurrences;
                
                // Free previous allocation if any
                if (mostPopularFilm != NULL) {
                    free(mostPopularFilm);
                }
                
                // Allocate and copy the film name
                mostPopularFilm = strdup(currentNode->elem.name);
            }
            
            currentNode = currentNode->next;
        }
    }
    
    return mostPopularFilm;
}

// Return a pointer to the subscriptions of the client with the specified document
tSubscriptions* subscriptions_findByDocument(tSubscriptions data, char* document);
    
    // Initialize the result
    subscriptions_init(result);
    
    // If the input data is empty, return an empty result
    if (data.count == 0 || document == NULL) {
        return result;
    }
    
    // Count how many subscriptions match the document
    int matchCount = 0;
    for (int i = 0; i < data.count; i++) {
        if (strcmp(data.elems[i].document, document) == 0) {
            matchCount++;
        }
    }
    
    // If no matches, return an empty result
    if (matchCount == 0) {
        return result;
    }
    
    // Allocate memory for the matching subscriptions
    result->elems = (tSubscription*)malloc(matchCount * sizeof(tSubscription));
    if (result->elems == NULL) {
        free(result);
        return NULL;
    }
    
    // Copy the matching subscriptions
    int resultIndex = 0;
    for (int i = 0; i < data.count; i++) {
        if (strcmp(data.elems[i].document, document) == 0) {
            subscription_cpy(&(result->elems[resultIndex]), data.elems[i]);
            resultIndex++;
        }
    }
    
    // Update the count
    result->count = matchCount;
    
    return result;
}

// return a pointer to the subscription with the specified id
tSubscription* subscriptions_findHash(tSubscriptions data, int id);

////////////////////////////////////////////

#endif
